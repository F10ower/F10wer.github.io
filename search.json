[{"title":"[DASCTF2024夏季挑战赛]StrangePrograme","url":"/2024/07/25/DASCTF2024夏季挑战赛-StrangePrograme/","content":"眼前所见，亦非真实\n<!--more-->\n你看到的我并不是真正的我，你看到的memcmp不是真正的memcmp\n\n![image-20240725170939564](image-20240725170939564.png)\n\n为什么memcmp要保留它当memcmp函数的历史\n\n因为它是钩子\n\n\n\n.DASCTF段一大段爆红，首先想到smc\n\n![image-20240725171825345](image-20240725171825345.png)\n\n跟随IsDebuggerPresent()的脚步来到这个函数\n\n![image-20240725171845428](image-20240725171845428.png)\n\n找到smc的地方\n\n![image-20240725171906045](image-20240725171906045.png)\n\n下面是被加密的.DASCTF段\n\n![image-20240725171927351](image-20240725171927351.png)\n\n断点一打，开始调试\n\n.DASCTF段解密后恢复里面的几个关键函数\n\n这里，memcmp被hook了，它已经不是原来的memcmp了\n\n![image-20240725171947690](image-20240725171947690.png)\n\n这里是加密\n\n![image-20240725172013011](image-20240725172013011.png)\n\nTEA\n\n![image-20240725172026696](image-20240725172026696.png)\n\n此时如果回主函数找到memcmp，一路跟进，会来到这个地方，这是动态链接库里的memcmp\n\n![image-20240725172046275](image-20240725172046275.png)\n\n> 总得来说，被hook的函数会改变它原本的功能，所以main函数里的memcmp并不是比较，而是加密\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid De_tea(unsigned int *a1, unsigned int *a2)\n{\n\n    unsigned int i; // [esp+DCh] [ebp-2Ch]\n    int v4;     // [esp+E8h] [ebp-20h]\n    unsigned int v5;    // [esp+F4h] [ebp-14h]\n    unsigned int v6;    // [esp+100h] [ebp-8h]\n\n    v6 = *a1;\n    v5 = a1[1];\n\n    // for (i = 0; i < 16; ++i)\n    // {\n    //     v6 += (a2[1] + (v5 >> 5)) ^ (v4 + v5) ^ (*a2 + 16 * v5);\n    //     v5 += (a2[3] + (v6 >> 5)) ^ (v4 + v6) ^ (a2[2] + 16 * v6);\n    //     v4 -= 1640531527;\n    // }\n    v4 = 0 - 16 * 0x61C88647;\n    for (i = 0; i < 16; ++i)\n    {\n        v4 += 0x61C88647;\n        v5 -= (a2[3] + (v6 >> 5)) ^ (v4 + v6) ^ (a2[2] + 16 * v6);\n        v6 -= (a2[1] + (v5 >> 5)) ^ (v4 + v5) ^ (*a2 + 16 * v5);\n        \n    }\n\n    *a1 = v6;\n    a1[1] = v5;\n}\n\nint main(){\n\n    __int64 v1;      // rax\n    __int64 v3;      // [esp-8h] [ebp-24Ch]\n    int j;           // [esp+D0h] [ebp-174h]\n    size_t i;        // [esp+F4h] [ebp-150h]\n    char *v6;        // [esp+100h] [ebp-144h]\n    unsigned int v7; // [esp+124h] [ebp-120h] BYREF\n    int v8;          // [esp+128h] [ebp-11Ch]\n    int v9;          // [esp+12Ch] [ebp-118h]\n    int v10;         // [esp+130h] [ebp-114h]\n    unsigned char v11[41];   // [esp+13Ch] [ebp-108h] BYREF\n    int savedregs;   // [esp+244h] [ebp+0h] BYREF\n\n    v11[0] = 0xF9;\n    v11[1] = 0x4D;\n    v11[2] = 0x2B;\n    v11[3] = 0xBC;\n    v11[4] = 0x13;\n    v11[5] = 0xDD;\n    v11[6] = 0x13;\n    v11[7] = 0x62;\n    v11[8] = 0xC9;\n    v11[9] = 0xFC;\n    v11[10] = 0xFF;\n    v11[11] = 0x89;\n    v11[12] = 0x7D;\n    v11[13] = 0x4F;\n    v11[14] = 0xC9;\n    v11[15] = 0xF;\n    v11[16] = 0x63;\n    v11[17] = 0x1D;\n    v11[18] = 0x6D;\n    v11[19] = 0x52;\n    v11[20] = 0x50;\n    v11[21] = 0xFD;\n    v11[22] = 0x41;\n    v11[23] = 0xE3;\n    v11[24] = 0x33;\n    v11[25] = 0x76;\n    v11[26] = 0x28;\n    v11[27] = 0x97;\n    v11[28] = 0x38;\n    v11[29] = 0x36;\n    v11[30] = 0xF9;\n    v11[31] = 0x6B;\n    v11[32] = 0x90;\n    v11[33] = 0x39;\n    v11[34] = 0x14;\n    v11[35] = 0x83;\n    v11[36] = 0x2C;\n    v11[37] = 0xE2;\n    v11[38] = 0x2C;\n    v11[39] = 0x1F;\n    v11[40] = 0x0;\n\n    // unsigned int enc[10] = {\n    //     0xBC2B4DF9, 0x6213DD13, 0x89FFFCC9, 0x0FC94F7D, 0x526D1D63, 0xE341FD50, 0x97287633, 0x6BF93638,\n    //     0x83143990, 0x1F2CE22C};\n\n    // unsigned int key[4] = {\n    //     0x12345678, 0x09101112, 0x13141516, 0x15161718};\n    // v8 = *(v11 + 1);\n    // *v6 = v8;\n    unsigned char key[16] =\n        {\n            0x78, 0x56, 0x34, 0x12, 0x12, 0x11, 0x10, 0x09, 0x16, 0x15,\n            0x14, 0x13, 0x18, 0x17, 0x16, 0x15};\n\n    unsigned int *p = (unsigned int *)v11;\n\n    for (int i = 8; i >= 2;i -= 2){\n\n        // *&v11[4 * i + 4] ^= *v11;\n        // *&v11[4 * 1] ^= *v6;\n\n        \n        // *(unsigned int *)&v11[4 * i + 4] ^= p[1];\n        // *(unsigned int *)&v11[4 * i] ^= p[0];\n\n        *(unsigned int *)&v11[4 * i + 4] ^= v11[1];\n        *(unsigned int *)&v11[4 * i] ^= v11[0];\n\n        // enc[i] ^= enc[1];\n        // enc[i - 1] ^= enc[0];\n\n        De_tea(p, (unsigned int *)key);\n        // De_tea((unsigned int *)v11, (unsigned int *)key);\n    }\n\n    De_tea(p, (unsigned int *)key);\n\n    for(int i = 0; i < 40;++ i)\n        printf(\"%c\", v11[i]);\n\n    return 0;\n}\n```\n\n接下来表演的节目是神奇的指针\n\n当我将exp中间部分写成这样时\n\n```c++\n*(unsigned int *)&v11[4 * i + 4] ^= *(unsigned int *)v11[1];\n*(unsigned int *)&v11[4 * i] ^= *(unsigned int *)v11[0];\n```\n\n它的输出是这样的\n\n![image-20240725172154625](image-20240725172154625.png)\n\n当我写成这样时\n\n```C++\nunsigned int *p = (unsigned int *)v11;\n*(unsigned int *)&v11[4 * i + 4] ^= p[1];\n*(unsigned int *)&v11[4 * i] ^= p[0];\n```\n\n它的输出是这样的\n\n![image-20240725172217958](image-20240725172217958.png)\n\n当我写成这样时\n\n```C++\n*(unsigned int *)&v11[4 * i + 4] ^= v11[1];\n*(unsigned int *)&v11[4 * i] ^= v11[0];\n```\n\n它的输出是这样的\n\n![image-20240725172259527](image-20240725172259527.png)\n\n指针，很神奇吧\n","tags":["比赛复现"],"categories":["逆向"]},{"title":"临江仙","url":"/2024/07/25/临江仙/","content":"青山依旧在，几度夕阳红\n<!--more-->\n# 临江仙\n## 【明】杨慎\n滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。\n白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。\n","tags":["宋词"],"categories":["古文"]}]